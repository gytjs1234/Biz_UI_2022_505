<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
   
    
    <title>Document</title>
    <style>
        div{
            width: 600px;
            background-color: aliceblue;
            margin: 20px;
          
            padding: 10px;
            line-height: 30px;
           
            box-shadow: 2px 3px 3px 0.5px black;
        }
        body{
            background-color: rgb(208, 162, 170);
            padding: 0%;
            margin: 0%
            ;
        }
        a{
            text-decoration: none;
            color: inherit;
        }
        .a{
            width: 400px;
            background-color: antiquewhite;
            float: left
            ;
            padding: 0px;
        }

    
       
        ul{
            background-color:cornsilk ;
            display: inline-block;
            padding: 10px;
            box-shadow: 10px 10px 10px  black;
            margin-left: 20px;
        }
        footer{
            background-color: rgb(165, 88, 129);
            height: 40px;
            padding: 0;
            margin: 0;
            
            ;
           
        }
       
    </style>
</head>
<body>
    <header>
    <a   href="java_class.html">뒤로가기</a></header>
    
   <div class="d">
<h3>변수 명명규칙과 패턴</h3>
<p>1.첫글자 무조건 소문자<br>
    2.이후에는 대소문,숫자,_를 조합할수 있다<br>
    3.두개 이상의 단어를 조합하여 만드는것이 좋다<br>
     4.두개 이상의 단어를 조합할떄 두번째 단어부터 대문자<br>
     =>camel case<br>
     5.두개 이상의 단어를 조합할때 첫번쨰 단어는
     변수의 type으로 만드는 것이 좋다<br>
     =>헝가리언 표기법</p>
     <p>
       <h3> 좋은 변수 이름짓기 </h3>
        변수명이 길어지더라도 2개 이상의 단어를 조합하자<br> 
        변수명만 보고 어떤 데이터가 담겨있는지 유추하자  
        <h3>변수규칙</h3>
        1.class가 달라지면 같은 이름 써도 된다. <br>
        2.변수에 값을 정장 할당 대입하거나 읽을려면 반드시 이전에 변수가
		최소한 선언되어 있어야한다.<br>
        3.같은 변수명은 한블럭 내부에서 두번이상 선언할수없다.<br>
        4.main() {} 블럭에서 선언된  변수는
		main() {} 블럭이 끝나는 시점에 소멸된다.<br>
        5.변수에 값을 할당, 대입 저장하기하면
        명령문이 실행되는 순간 이전에 변수에 어떤 일이 있던지 상관없이 모든값이 clear되고
        최근에 저장한 값이 담긴다. <br>
        6.변수의 개수는 제한이없음 단 변수안에 저장되는 값은 제한이있음 <br>
        7.int 변수는 int type 이기때문에 2의 32승 -1 까지 값만 저장가능<br>
        8.할당 명령문(변수에 값을 할당, 저장, 대입하는 명령문)에
	    연산식이 따라오면 먼저EQ(=)의 오른쪽 연산을 항상 먼저 실행한다
	           그리고 실행한 결과를 왼쪽의 변수에 저장한다.
	
     </p>
     <h3>변수 사용하기</h3>
     두 단어 이상으로 조합할 경우 두번쨰 단어의 첫글자는 대문자로 작성하여보기 쉽도록 하자 : Camel case 라고 한다<br>
     <strong>*</strong>변수명 명명방법을 강조하는 이유는 팀단위 프로젝트를 진행할때 코드공유 등의 문제를최소화 하기 위하여 하는 것이다. <br>
     <strong>*</strong>변수명은 절대 키워드(예약어)를 사용할수 없다 : ex) public ,class, void ....
    
   </div> 
   <div>
        <h3>코드에서 사용되는 수의 체계</h3>
		
	 <h4>정수형(int type), 실수형(float type)</h4>
		
		  int:정수형 데이터를 저장할 기억장소를 예약해달라<br>
           num1:예약한 기억장소에 쉬운 num1이라는 이름을붙여라<br>
	
		  정수형 변수 num1을 선언하고 정수 255 값으로 초기화하라  <strong> int num1 = 255;</strong><br>
		  정수형 변수 num2를 선언하고 정수 88 값으로 초기화하라    <strong>int num2 =88;</strong><br>
          <p>
          변수에 어떤 값을 저장해야할지 아직 정해지지 않았을때  
		   숫자일 경우는 0으로 초기화를 해 둔다(clear라고 표현)<br>  <strong>int num5=0; int num5=0; </strong>
        </p>

   </div>
   <div>
      <p> *System.out.println(); : main 블럭의 밖에서는 명령문 사용불가*</p>
       int 형 변수는 큰값을 저장할수없다<br>
       만약 큰 정수 값을 저장하려하면 long type 으로 변수를 선언해야 한다. <br>
    <strong>   long longNum1 = 0;<br>
       longNum1 = 999_999_999_999_999_999L;</strong>      (2의64승까지 저장가능)
   </div>
<div id="b"> 
    
    <strong> int intSum = 0;</strong><br>
    <strong> int intNum1 = 77; </strong>    intNum1 변수의 값을 읽어서 CPU에 가져오기<br> 
        <strong>int intNum2 = 99; </strong>	 intNum2 변수의 값을 읽어서 CPU에 가져오기 <br>
            <strong> intSum = intNum1 + intNum2; </strong>	 두값을 덧셈하여 결과를 변수 intSum에 저장하면<br>
                <strong>System.out.println(intSum); </strong>intsum결과 출력하기<br>
    
   
     

</div>
<ul>
  <p>
	int intSum = 0;          합<br>
    int intDeffrence = 0;   차 (뺄셈한 값)<br>
   int intProduct = 0;     곱<br>
   int intDivide = 0;       나눗셈<br>
   int intMod = 0;         나머지<br>
</p>
<p>
   intSum = intNum1 + intNum2;<br>
	intDeffrence = intNum1 - intNum2;<br>
	intProduct = intNum1 * intNum2;<br>
	intDivide = intNum1 / intNum2;<br>
	intMod = intNum1 % intNum2;<br>
</p>  
</ul>
<div>
    0부터 1000미만의 임의의 실수를 생성하여
    변수에 저장해달라. <br>
	<strong> double doRnd = Math.random() * 1000; 
    </strong> <br>
    실제 필요한 코드는 0~999까지의 정수만 필요하다.

    <h3>강제 형 변환, 명시적 형 변환</h3>
	실수값을 정수변수에 저장하면 
	기억장치의 크기 때문에 오류가 발생한다.
	그렇기 떄문에 코드는 오류메세지를 보여준다.
	하지만 개발자가 실수값 중에서 소수점 이하는 필요가 없고
	정수 부분만 필요하니 소수점 이하 값을 제거하고
	정수부분만 intRnd 변수에 담아달라고 
	강제로 명령을 내린다.
	이떄는 type 키워드를 () 묶어 변수 앞에 표식한다.
	<h3>자연 형 변환, 묵시적(암시적) 형 변환</h3>
	 실수 =정수 와같은 명령을 수행하면
	실수형변수는 정수값을 저장하기에 충분히 큰 기억장치 이므로
	문제가 발생하지 않는다.
	<strong> double num =30;</strong> 과 같은 코드가 실행되면
	 num 변수에는 30.00000과 같이 저장이 된다. <br>
	<strong> int intRnd = <span style="color: red;">(int)</span>doRnd;</strong>

    <h3>기본 실수타입(소수점 이하 13자리)</h3>
	<strong>	double douNum = 30;</strong>  30.0이 저장된다. <br>
		<strong>   int intNum = <span style="color: red;">(int) </span>douNum;</strong>  실수형 값을 정수형에 강제로 저장 <br>
        실수타입의 변수가 필요하기는 한데 
		굳이 소수점 이하 13자리까지의 정밀도가 필요 없을 경우 <br>
		 
      <strong> float foNum = 30;</strong> <br>
		
		
		float 형은 double 형보다 정밀도가 낮은 실수형 변수다.
</div>
<ul>
   <strong> int intNum1 = (int)(Math.random()* 1000); <br>
	int intNum2 = (int)(Math.random()* 1000);<br>
	
	
	int intSum = intNum1 + intNum2;<br>
	System.out.printf("%d +%d=%d",intNum1,intNum2,intSum);</strong><br>
	
</ul>
<div>
    <h2>실수형</h2>
   <ul><strong> double doNum1 = Math.random()*1000; <br>
    double doNum2 = Math.random()*1000;<br>
    
    double dosum = doNum1 + doNum2;<br>
    double doDes = doNum1 - doNum2;<br>
    double doMulti = doNum1 * doNum2;<br>
    double doDiv = doNum1 / doNum2;</strong><br></ul>
   <br>
   <br>
    <h4>prinf()를 사용하여 3개의 변수에 담긴 데이터를  console 에 출력하기</h4>
    "%d+%d+=%d" form String 을 사용하여 출력할 모양을 지정하고
    각각 %d에 위치에 표현할 데이터를 3개 나열했다 <br>
    <strong>	 System.out.printf("\t%d + %d = %d\n",doNum1,doNum2,dosum);  </strong><br>
    여기애 %d는 Decimal(10진수) 를 표현하는 키 단어이다<br>
     그런데 doNum1, doNum2 ,doSum 변수는 double type 이다<br>
    double type 변수에 담긴 값을 %d로 표현하려면
    내부에서 데이터 type 문젤 인한 중대한 문제가 발생한다.<br>
%d는 정수만 표현할수 있는데 실수 값을 표현하라고 했기 때문에 발생하는 문제<br>
    <br>
<strong>
System.out.printf("%f + %f = %f",doNum1,doNum2,dosum);<br></strong>
 %.2f:정수부분은 모두 표현하고 소수점이하 2쨰자리까지 출력하라.<br>
 <strong>
System.out.printf("%.2f + %.2f = %.2f",doNum1,doNum2,dosum);<br>
System.out.printf("%.2f + %.2f = %.2f",doNum1,doNum2,dosum);<br>
System.out.printf("%.2f x %.2f = %.2f",doNum1,doNum2,doMulti);<br></strong>
<br>

 %8.2f: 전체 자릿수를 8개로 하고 소수점 이하 2째까지 표현<br>
 만약 데이터가 전페 자릿수 보다 작으면 남은 부분을 공백으로 표현<br>
 숫자를 오른쪽으로 정렬할때 사용하는 방법<br>
 8.2 :정수자릿수+ 소수점(1) + 소수점이하 2자리를 모두 합란 개수가 
 8개 라는 표현이다
 그래서 전체 자릿수가 8개를 넘어가면 form 이 흐트러지는 경우도 있다<br>
 충분히 표현할 수 있는 자릿수로 만들기<br>
<strong>System.out.printf("%.2f + %.2f = %8.2f",doNum1,doNum2,dosum);<br>
System.out.printf("%.2f x %.2f = %8.2f",doNum1,doNum2,doMulti);<br></strong>

*prinf()를 사용하여 실수 데이터를 Console 에 출력하려면 %f 기호를 사용하여 표현해야 한다. *<br>

</div>


<div>
    Math.radom()이 실행된 결과가 담긴 doNum1 변수의 값에 1000을 곱하여 다시 doNum1에
    저장하라 <br>
    doNum1 = doNum1 * 1000;과 같다<br>
    doNum1 :0.000~999.999범위의 실수가 저장<br>
    
    double doNum1 = Math.random()*1000; <br>
    doNum1*=1000;
<hr>
doNum1 에 담긴 값에 1을 더하여 다시 doNum1에 저장
	 * doNum1:1.000~1000.999범위의 실수가 저장 <br>
  <strong>  doNum1 ++; <br></strong>
    <hr>
<h4>	정수값으로 변환 <br></h4>
	intNum1 : 1~1000범위의 정수가 저장 <br>
	int intNum1 = (int)doNum1; <br>
	 doNum1 = Math.random()*1000 +1 ;<br>
	int intNum2 = (int)doNum1;<br>
	
	int intSum =intNum1 +intNum2;<br>
	int intDes =intNum1 -intNum2;<br>
	int intMulty =intNum1 *intNum2;<br>
	int intDiv =intNum1 /intNum2;<br>
결과출력 <br>
    System.out.printf("\t%d+%d=%d\n",intNum1,intNum2,intSum);
	System.out.printf("\t%d-%d=%d\n",intNum1,intNum2,intSum);
	System.out.printf("\t%d*%d=%d\n",intNum1,intNum2,intSum);
	System.out.printf("\t%d/%d=%d\n",intNum1,intNum2,intSum);
</div>
<div>
    <h3>문자형 변수타입</h3>
     문자(영문자,숫자,한글 1글자,특수문자)를 저장하는 변수 type 
	 문자를 작은따옴표 (sQ)로 묶는다.
	 키보드로 입력할수 있는 문자를 저장하는 변수
	 
	<ul> char charA ='가'; <br>
	 char charB ='A';<br>
	 
	 
	 System.out.println(charA);<br>
	 System.out.println(charB);<br>
	 
	 System.out.printf("\t%c\n",charB);<br>
	
	int intA = (int)charA;<br>
	int intB = (int)charB;</ul><br>
	
	charA,charB에는 '문자'가 저장되어 있다. <br>
	charA: '가', charB :'A'가 저장되어 있지만
	실제 저장된 값은 문자의 표현을 10진수로 바꾸어 저장한다
	저장된 10진수는 정수형으로 바꾸어 실제 값을 확인 할수 있다.
	
	intA =(int)charA: Unicode 형식의 '가' 문자의 실제 데이터
	(코드값)을 정수형 값으로 변환하여 저장 <br>
	intB=(int)charB:ASCII 형식의 'A'문자의 실제 <br>
	데이터(코드값)를 정수형 값으로 변환하여 저장 <br>
	stem.out.printf("%c:%d ",charA,intA); /*유니코드*/ <br>
	System.out.printf("%c:%d ",charB,intB); <br>
	//변수에 저장된 문자와 문자의 코드값(code value) 을 확인

    <h3>문자열형 변수타입</h3>
        String type 또는 문자열형 변수 선언<br>
		="": 선언된 문자열형 변수를 clear <br>
		(숫자형에서 0을 대입한것과 유사)<br>
		
		 
	<strong>	String strNation="";</strong><br>
		
		=null : 선언된 문자열형 변수를 clear<br>
		<strong>String strName = null;</strong><br>

        int intAge =(int)(Math.random()*100) + 10; //10살부터109세
</div>
<div>
    <h2>문자열형 변수 저장방식</h2>
    문자열형 변수는 숫자형, 불린형 변수와 저장방식이
다르다 <br>
떄문에 문자열형 변수에 저장된 문자열을 EQ(==)비교를 하는것은
매우 위험한 코드가 될수 있다. <br>
문자열형 변수는 절대EQ(==)또는 Not EQ(!=)를 사용하여
비교하지 않는다. <br>
<br>
<strong >
String strName = new String("홍길동"); <br>
System.out.println(strName); <br>
System.out.println(strName=="홍길동");</strong> <br>
답은? false <br>
<hr>
<strong>strNation ="Republic of Korea"; <br>
bYes = strNation.equals("Republic of Korea") ; <br>
답은? true 
</strong>	

      <strong> 
        String strNation ="KOREA"; //문자열 변수선언  
        
        method Chaining
		bYes = strNation. <span> toUpperCase().equals</span>("REPUBIC OF KOREA" ); <br>
		bYes= strNation.<span>toLowerCase().equals</span>("republic of korea");<br>
		
		대소문자를 무시하고 문자열을 비교하라  띄어쓰기는 무시하지않는다<br>
		bYes =strNation.<span>equalsIgnoreCase</span>("republic of Korea");</strong><br>
</div>

<footer>
    
</footer>
</body>
</html>